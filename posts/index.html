<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Rain Blog</title>
<meta name=keywords content><meta name=description content="Posts - Rain Blog"><meta name=author content="Afer_rain"><link rel=canonical href=https://hugo.123450908.xyz/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://hugo.123450908.xyz/posts/index.xml><link rel=alternate hreflang=zh href=https://hugo.123450908.xyz/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hugo.123450908.xyz/posts/"><meta property="og:site_name" content="Rain Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="like computer"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://hugo.123450908.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hugo.123450908.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="like computer"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hugo.123450908.xyz/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hugo.123450908.xyz/ accesskey=h title="Home (Alt + H)"><img src=https://hugo.123450908.xyz/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hugo.123450908.xyz/posts/ title=学习><span class=active>学习</span></a></li><li><a href=https://hugo.123450908.xyz/live/ title=生活><span>生活</span></a></li><li><a href=https://hugo.123450908.xyz/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header style="background-image:url(/images/dd02.webp);background-size:cover;background-position:50%;padding:3rem 1rem;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,.3);text-align:center;position:relative"><div style="position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(to right,rgba(0,0,0,.3),rgba(0,0,0,.1));z-index:0"></div><div style="position:relative;z-index:1;max-width:1200px;margin:0 auto"><h1 style=margin:0;font-size:2.8rem;font-weight:700>Posts</h1></div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Debian 系统精簡</h2></header><div class=entry-content><p>这两个目录是 Debian 系统中常见的大户，进一步清理可以重点针对它们。
1. /usr 目录清理建议 /usr 主要存放系统程序和共享资源，通常包含：
/usr/share/doc：软件说明文档 /usr/share/man：手册页 /usr/share/locale：多语言本地化文件 /usr/share/fonts：字体文件 /usr/lib：库文件和程序文件 /usr/bin、/usr/sbin：可执行文件 清理重点 删除说明文档和手册页
rm -rf /usr/share/doc/* rm -rf /usr/share/man/* rm -rf /usr/share/info/* 删除不需要的语言文件
如果只需要简体中文（zh_CN）和英文（en），可以删除其他语言的本地化文件：
find /usr/share/locale -mindepth 1 -maxdepth 1 ! -name "zh_CN" ! -name "en" -exec rm -rf {} + 字体清理
同之前脚本，保留简体中文和英文字体，删除其他字体。
检查大文件
你可以用如下命令列出 /usr 下大于 10MB 的文件，确认是否有可删文件：
find /usr -type f -size +10M -exec ls -lh {} \; 2. /var 目录清理建议 /var 目录通常包含：
/var/cache：缓存文件 /var/log：日志文件 /var/lib：应用程序数据 /var/tmp：临时文件 清理重点 清理 apt 缓存
...</p></div><footer class=entry-footer><span title='2025-12-12 00:00:00 +0000 UTC'>十二月 12, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;363 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to Debian 系统精簡" href=https://hugo.123450908.xyz/posts/2025-12-12/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>提升PR剪辑效率的二十二个必备技巧</h2></header><div class=entry-content><p>在之前的文章中，已经向大家介绍了PR的小技巧，许多小伙伴直呼需要更多这样的干货，pr软件是自带很多小工具，可以为制作提升很高的效率。这些小工具如果能全部掌握，就相当于十八般兵器，随便拿出来一两个，都能让剪辑工作如虎添翼。如果不能全部掌握，随便几个小技巧也能让你感叹软件的流畅。
技巧一：快速波纹剪辑（Shift+W/Q） 许多小伙伴，在剪辑素材时，通常会通过C剃刀工具将要剪辑的内容给剪切开，或者使用Ctrl+K来切割素材，然后使用D选中素材并删除，这样会比较麻烦，其实直接按下Q或者W就可以使用波纹剪辑效果自动剪辑素材并且与之前的素材相连。如果你想相应延长一段素材至空白区域，只需要按下Shift+Q或者W即可。
技巧二：快速设置工作区（I/O ） 如果你想从素材中删除或者抽取某一素材的中间部分时，你可以通过I和O键选择工作区，随后使用（；）来删除工作区内的片段，如果你想抽取这个片段，只需要按下引号键（‘’）就可以完成。
技巧三：快捷导入素材 通常我们导入素材，是双击项目窗口，选中相应素材点击打开进行导入，如果导入的素材很多，都在同一个文件夹内，是无法双击导入进去的，可以将素材文件夹直接拖入项目窗口，导入之后也是你自己分好类的文件夹，这样就可以完成，比单独一个个拖拽效率要高不少。
技巧四：快速替换素材 当我们剪辑时发现想将时间轨道上的某一段素材替换成另一段素材时，很多小伙伴的做法是先删除这段素材，然后再将另一段素材拖入被删除素材的位置，极为麻烦，快捷的方式：选择要替换的素材，直接将素材拖入窗口，这样就完成了替换。同样插入、覆盖等功能也可以快速实现。
技巧五：批量添加转场 很多时候我们都需要为多个素材添加转场，使用鼠标挨个添加的话，效率会非常低下，直接选中所有的你需要添加转场的素材，快捷键：Shift+D可以快速为你加上音频和视频的转场，如果单独为视频添加转场，快捷键：Ctrl+D，如果你想为音频添加转场，
快捷键：Ctrl+Shift+D。如果你想修改转场的类型，你可以进入到效果面板，选择你需要设置为默认的转场，右键，点击设置为默认，接下来你按下快捷键就能迅速添加这个转场。
技巧六：自动选中素材 很多情况下在我们拖动时间线的时候，需要点击一下素材才可以选中，很麻烦，点击“序列”窗口，选择点击跟随播放指示器，可以直接实现指针拖到那个素材就自动选择该素材，大大提升剪辑效率。
技巧七：平行时间轴 做剪辑会有不同的序列，根据内容不同会分为主序列与子序列，主序列一般就是我们最终的输出序列，点击子序列将其拖入主序列下方，得到两个平行的时间轴，下方子序列可以为上方的主序列提供素材，素材可以直接从下方序列中拖入主序列。子序列可以不止一个，根据自己的需要进行设置。
技巧八：素材间互换位置（Alt+ctrl+拖动） 当你要把两段素材互换位置的时候，按住Ctrl+alt+鼠标左键拖动素材可以快速调换素材位置并且自动对正。
技巧九：快速预览（L） 如果我们使用空格来预览素材，那么速度很慢。序列窗口按“L键”可以快速预览，多按几次L我们视频播放的速度会更加的快，按一次“空格键”我们视频播放会停止，再按一次“空格键”视频的播放速度会回归正常。在素材很多的情况下可以这样预览。
技巧十：标记素材（标识帧） 使用标识帧设置关键的画面，方便在素材库里面查找，素材窗口拖动素材时间轴预览，选择合适位置后右键设置标识帧（方便区分素材）
技巧十一：在轨道上复制素材（Alt+拖动） 当你想要在时间轨道上复制素材的时候，如果一个一个的复制，感觉好慢呀，许多人使用ctrl+c对素材进行复制，但是在拖动的时候可能会把原有的素材覆盖，其实只要按住Alt+拖动，就可以快速复制。
技巧十二：一次性剪切全部轨道（shift+c） 当你使用了多个轨道的时候，需要进行裁切的时候，一般只能一次裁切一个素材，这个时候只要按住Shift+c键就可以对视频与音频上的所有轨道进行裁切。
技巧十三：从素材库中插入素材（英文“，”键） 当你已经剪辑完一段素材的时候，如果想在其中某个位置插入另一段素材，只要把时间标尺放在要插入的位置，选中素材按，然后在英文输入法下按“，”键，这样就可以快速插入轨道。
技巧十四：快速全选右侧素材（A键） 这个可以快速选择一大段素材，不用鼠标先把素材缩小再全选，直接一键搞定。
技巧十五：批量调色 可以在素材窗口右键新建“调整图层”，将调整图层放在素材上面，只对调整图层调色。
技巧十六：匹配帧 如果你经常想在素材箱里找到对应时间线上的素材但是却不知道怎么做，那么F键就会是你的救星，只需要按下F键，你就能够在素材监视器上找到对应的帧，这样可以有效的帮助你进行素材的替换或者修改。如果你想从素材监视器上找到时间线上对应的帧，只需要按下Shift+R就可以实现。
技巧十七，时间轴放大 通常我们使用+/-号缩放时间轴，但是你也可以使用反斜杠来进行快速缩放，只需要按一下你就可以缩放到整个序列的长度，再按一下就可以回到之前的状态，相对效率会比加减号高很多。你也可以按下Ctrl+反斜杠来隐藏顶部的项目信息，对于屏幕较小的朋友这一点会很有用。
技巧十八：移动剪辑 通常我们都需要鼠标移动剪辑，但是当你按下D选中对应素材以后其实你是可以按住Alt和上下左右键移动素材位置的，需要注意的是需要激活相应的轨道才能够进行移动，如果你想用更快的速度移动素材，那你可以按住Alt+Shift+方向键来快速拖动素材
技巧十九：抽取与删除 当你想删除或者抽取一段素材的中间部分时，你可以通过i和o键设定工作区，随后使用分号键来删除工作区内的片段，如果你想抽取这个片段，只需要按下引号键就可以轻松实现。
技巧二十：轨道扩展 如果视频轨道太窄，通常你会需要使用鼠标滚轮放大相应的轨道，但是这样会花费不少时间，所以你可以选择使用Ctrl+加减号来缩放单个轨道的宽度，如果你想一次性扩展或者缩小所有轨道，那你可以使用Shift+加减号。
技巧二十一：迅速切换窗口 当你选中一个窗口的时候，你就没法操控另一个窗口，传统的切换方法是使用鼠标点击，但是很少有人知道通过按住Shift+123你可以自由切换你所需要前往的窗口，这个可以大大提升你的工作效率，例如你可以迅速切换到素材监视器，设定出入点后将素材插入到时间线上来进行进一步的处理，这是我最经常使用的快捷键。
技巧二十二：快速选择输出范围 剪辑完成后，需要选择整体的输出范围，这个时候，常规的做法是用鼠标拖动入点和出点，以确定范围，但经常容易漏帧。
快捷的方法是英文输入法下，点击键盘的“/” 反斜杠，和问号是同一个键。
...</p></div><footer class=entry-footer><span title='2025-08-24 00:00:00 +0000 UTC'>八月 24, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;52 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to 提升PR剪辑效率的二十二个必备技巧" href=https://hugo.123450908.xyz/posts/2025-08-24/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Armbian 环境下安装并配置 Crawl4</h2></header><div class=entry-content><p>### 前言：为什么 Armbian 与众不同？ Crawl4AI 是一个强大的网页抓取工具，但它依赖的底层浏览器自动化库 Playwright 官方主要提供为普通电脑/服务器（x86_64 架构）编译的浏览器。我们的 Armbian 系统运行在 ARM 架构上，因此无法使用官方的自动安装程序。本指南的核心就是绕过这个限制，手动配置，让 Crawl4AI 在 Armbian 上完美运行。
### 第一步：系统环境准备 (安装系统版浏览器) 我们不使用 Crawl4AI 自带的安装脚本，而是直接从 Armbian 的软件库中安装已经为 ARM 架构编译好的 Chromium 浏览器。
更新软件列表并安装 Chromium:
Bash
sudo apt-get update sudo apt-get install -y chromium-browser 获取浏览器路径:
安装完成后，运行以下命令找到它的可执行文件路径，并复制这个路径以备后用。
Bash
which chromium-browser (通常路径为 /usr/bin/chromium-browser)
### 第二步：安装 Python 包并初始化环境 接下来，我们安装 Crawl4AI 的 Python 包，并进行一个关键的环境初始化步骤。
使用 pip 安装 Crawl4AI:
Bash
pip install crawl4ai 初始化 Playwright 环境 (但不下载浏览器):
...</p></div><footer class=entry-footer><span title='2025-07-22 00:00:00 +0000 UTC'>七月 22, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;242 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to Armbian 环境下安装并配置 Crawl4" href=https://hugo.123450908.xyz/posts/2025-07-221/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>rclone挂载谷歌网盘</h2></header><div class=entry-content><p>运行 Rclone 官方安装脚本： 这个脚本会自动检测您的系统架构并下载安装最新稳定版的 Rclone。
Bash
curl https://rclone.org/install.sh | sudo bash 验证安装： 运行以下命令查看版本号，如果成功显示版本信息，则表示安装成功。
Bash
rclone version 测试配置: 运行以下命令，如果能列出您 Google Drive 根目录的文件和文件夹，说明配置成功！
Bash
rclone lsd gdrive: (注意：gdrive: 冒号不能少，gdrive 是您之前给远程连接起的名字)。
第二阶段：挂载 Google Drive 创建挂载点: 在您的主目录下创建一个文件夹，用来作为挂载点。
Bash
mkdir -p ~/gdrive 执行挂载命令:
Bash
rclone mount gdrive: ~/gdrive --daemon rclone mount: 挂载命令。
gdrive:: 您配置的远程名称。
~/gdrive: 本地挂载点目录。
--daemon: 让 rclone 在后台运行，这样您关闭 SSH 连接后挂载依然有效。
验证挂载:
使用 df -h 命令，您应该能看到一个类型为 fuse.rclone 的新文件系统。
使用 ls -l ~/gdrive 命令，您应该能看到您 Google Drive 里的文件。
...</p></div><footer class=entry-footer><span title='2025-07-22 00:00:00 +0000 UTC'>七月 22, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;440 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to rclone挂载谷歌网盘" href=https://hugo.123450908.xyz/posts/2025-07-22/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>vaultwarden直接deb文件安装</h2></header><div class=entry-content><p>vaultwarden.deb 包只包含了后端程序，它需要另一个独立的包来提供前端界面。
## 解决方案 🛠️ 最直接的解决方法就是安装缺失的前端包。
方案一：安装缺失的前端包 (推荐) 您需要回到最初下载 .deb 包的那个页面，找到并下载 vaultwarden-webvault 这个包。
下载前端包 第三方软件包 后端包 前端包 登陆：rain1226:ofen 在您下载 vaultwarden_1.34.1-1+1.1_amd64_ubuntu22.deb 的地方，应该还有一个类似下面这样命名的文件：
vaultwarden-webvault_2024.5.0_all.deb
(版本号 2024.5.0 可能会不同，架构通常是 all 因为它只包含网页文件)。
安装前端包
使用 dpkg 命令安装它。这个包通常没有复杂的依赖。
Bash
sudo dpkg -i vaultwarden-webvault_xxxx_all.deb (请将 xxxx 替换为您下载的实际文件名)
重启 Vaultwarden 服务
安装好前端文件后，它们就会出现在后端程序期望的位置。现在只需重启服务即可。
Bash
sudo systemctl restart vaultwarden 再次检查状态
等待几秒钟，然后再次检查服务状态，这次应该就是 active (running) 了。
Bash
sudo systemctl status vaultwarden Vaultwarden 的配置通常在 /etc/vaultwarden.cfg（取决于打包方式）。
打开这个文件，找到并修改 SIGNUPS_ALLOWED=true 为 SIGNUPS_ALLOWED=false，然后重启服务 sudo systemctl restart vaultwarden。</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0000 UTC'>七月 20, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;69 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to vaultwarden直接deb文件安装" href=https://hugo.123450908.xyz/posts/2025-07-201/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>编译Rust之Stump电子书库</h2></header><div class=entry-content><p>这就是编译和部署中最经典的困境：
编译时：我们需要一个新环境（Debian 12），因为它有程序源码需要的、新的开发工具和库（比如 libglib-2.0 >= 2.70）。
运行时：我们需要产物能在一个旧环境（Debian 11）上运行，因为它只有旧版的系统基础库（glibc）。
幸运的是，Rust 语言的工具链非常强大，它提供了一个完美的解决方案来解决这个悖论。
最终解决方案：静态编译 (Static Compilation using MUSL) 我们的最终目标是生成一个不依赖任何系统库的、完全独立的“绿色”程序。这样它就不再关心你的 VPS 是 Debian 11、12 还是其他什么系统了。
这个技术叫做“静态编译”，我们将使用一个名为 MUSL 的C语言基础库来替代主流的 GLIBC。
GLIBC (动态链接)：程序运行时，需要去“借用”操作系统的基础库。操作系统版本不对，就借不到，程序报错。
MUSL (静态链接)：在编译的最后一步，把所有需要的基础库功能，像“干粮”一样，全部打包进最终的程序文件里。程序运行时自给自足，完全不依赖外部系统。
这完美地契合了你最初“单文件，占用资源较少，不需要安装依赖”的设想。
终极操作指南：编译一个真正的静态程序 我们将继续使用 Debian 12 作为我们的编译环境（因为它有我们需要的新版开发工具），但我们会告诉编译器，我们的最终目标是生成一个基于 MUSL 的静态程序。
第一步：彻底清理旧环境 和上次一样，我们先删除旧的 stump-builder 容器，确保从一个干净的状态开始。
如果你还在容器里，请 exit。
在你本地电脑的终端运行：
Bash
docker stop stump-builder docker rm stump-builder 第二步：启动 Debian 12 编译容器 这一步和上次完全一样，我们仍然需要 Debian 12 的新环境来满足编译时的依赖。
Bash
docker run -it \ --name stump-builder \ -v "$(pwd)":/build \ --env "HTTP_PROXY=http://172.17.0.1:7890" \ --env "HTTPS_PROXY=http://172.17.0.1:7890" \ debian:12-slim \ /bin/bash 第三步：在 Debian 12 容器内执行全新的编译步骤 进入容器后，请一步步执行以下命令。注意，依赖包和编译命令都发生了变化。
...</p></div><footer class=entry-footer><span title='2025-07-20 00:00:00 +0000 UTC'>七月 20, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;209 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to 编译Rust之Stump电子书库" href=https://hugo.123450908.xyz/posts/2025-07-20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CSS选择器详解</h2></header><div class=entry-content><p>首先，一个核心概念要明确：
CSS选择器是一套独立的“语言”，它本身与Python或JavaScript无关。 无论你在哪里使用它，语法规则都是完全一样的。
在Python的BeautifulSoup里，你把选择器字符串传给 soup.select('...') 函数。
在JavaScript里，你把同样的字符串传给 document.querySelectorAll('...') 函数。
在CSS样式表里，你直接使用它来定义样式。
所以，学会了怎么写选择器，你就等于掌握了一项在所有这些技术中通用的技能。
JavaScript中如何使用CSS选择器 在JS脚本（尤其是在浏览器控制台里调试时），你主要会用到这两个函数：
document.querySelector('你的选择器')
作用：返回匹配到的 第一个 元素。
特点：如果找不到，返回 null。当你确定只有一个目标时，用它很方便。
document.querySelectorAll('你的选择器')
作用：返回匹配到的 所有 元素，以一个列表（NodeList）的形式。
特点：这是我们爬虫和调试时最常用的！它和Python里的 soup.select() 功能几乎完全一样。如果找不到，返回一个空列表。
这是你在将选择器放入Python代码前，进行测试的最佳方式！
CSS选择器参数写法“速查宝典” 下面，我为你整理了一份从入门到精通的CSS选择器写法“秘笈”，并结合 docs.crawl4ai.com 的例子来说明。
1. 基础选择器 (The Basics) 类型
语法
例子 (针对crawl4ai)
解释
标签
tag
h1
选取所有 &lt;h1> 标签。
类名
.classname
.terminal-mkdocs-side-nav-item
选取所有 class 属性包含这个类名的元素。
ID
#idname
#Introduction
选取 id 属性等于 Introduction 的元素（ID在页面中应唯一）。
2. 组合选择器 (Relationships) 这是最强大的部分，用来描述元素之间的层级关系。
类型
语法
例子
解释
后代
A B
...</p></div><footer class=entry-footer><span title='2025-07-14 00:00:00 +0000 UTC'>七月 14, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;258 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to CSS选择器详解" href=https://hugo.123450908.xyz/posts/2025-07-14/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>n8n使用code节点清洗数据</h2></header><div class=entry-content><p>crawl4ai真实数据结构，raw_markdown 的正确路径是：
item.json.results[0].markdown_v2.raw_markdown
我们来分解一下这个正确的路径：
item：这是 n8n 传给 Code 节点的单个数据项，它的顶层就有一个叫 "json" 的对象。
.json：进入这个 "json" 对象。
.results：在 "json" 对象内部，找到 "results" 字段，它是一个数组 [ ... ]。
[0]：从这个数组中，取出第一个元素（因为编号从0开始）。
.markdown_v2：在这个元素对象中，找到 "markdown_v2" 字段。
.raw_markdown：最后，从 "markdown_v2" 对象中，取出我们最终需要的 "raw_markdown" 文本。
你之前的尝试都非常接近，只是因为 crawl4ai 的输出实际上被包裹在了另一层 json 对象里，这是我们之前无法预料到的。你通过 console.log 把它找了出来，这正是最专业的调试方法！
最终的 n8n Code 节点代码 现在，请将你的 Code 节点代码完整替换为下面这个最终正确版本。它使用了正确的路径，并且依然保持了“健壮性”，可以防止因为未来可能的抓取失败而导致工作流崩溃。
JavaScript
// 获取上一个节点传入的所有数据项 const items = $input.all(); // 遍历每一个数据项进行处理 for (const item of items) { // 使用我们最终确定的正确路径来安全地访问数据 let text = item.json?.results?.[0]?.markdown_v2?.raw_markdown; if (text) { // --- 最终清理流程 --- // 1. 【关键新增步骤】将字符串 "\\n" 替换为真正的换行符 \n // 这是解决你看到 `\n` 而不换行的核心 text = text.replaceAll('\\n', '\n'); // 2. 定义一个更全面的“垃圾内容”关键词黑名单 const junkKeywords = [ '分类', '图像来源', '图像加注文字', '补充报导：BBC国际部', 'Article Information', 'Author,', 'Role,', '热读', 'End of 热读', '更多相关内容', '热门内容', '特别推荐', 'BBC值得信赖的原因', '© 2025 BBC' ]; // 3. 先用更强的正则表达式，移除所有图片和链接的 Markdown 标记 text = text.replace(/(!?\[[\s\S]*?\]\([\s\S]*?\))+/g, ''); // 4. 【核心改进】按行处理，用更严格的规则过滤 const lines = text.split('\n'); const cleanedLines = lines .map(line => line.trim()) // 去除每行首尾的空格 .filter(line => { // 规则a: 过滤掉空行 if (line.length === 0) return false; // 规则b: 过滤掉无意义的符号行 if (line === '*' || line === '###') return false; // 规则c: 过滤掉类似 "1. 1" 或 "10. 10" 这样的错误行 if (/^\d+\.\s\d+$/.test(line)) return false; // 规则d: 过滤掉看起来像单独日期的行 if (/^\d{4}年\d{1,2}月\d{1,2}日$/.test(line) || /^\d+\s小时前$/.test(line)) return false; // 规则e: 如果行内包含任何一个黑名单关键词，就过滤掉它 if (junkKeywords.some(keyword => line.includes(keyword))) return false; return true; // 保留所有“干净”的行 }); // 5. 将干净的行重新组合，并整理段落格式 let cleanedText = cleanedLines.join('\n'); cleanedText = cleanedText.replace(/\n{3,}/g, '\n\n'); // --- 清理流程结束 --- item.json.cleaned_markdown = cleanedText.trim(); } else { item.json.cleaned_markdown = "处理失败：未能在指定的路径中找到内容。"; } } // 返回被修改后的数据项 return items;</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0000 UTC'>七月 13, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;230 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to n8n使用code节点清洗数据" href=https://hugo.123450908.xyz/posts/2025-07-13/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>正确的Python Code Crawl4ai节点脚本</h2></header><div class=entry-content><p>正确的 Python Code ___Crawl4ai 节点脚本 这次的方案不再依赖任何需要从外部安装的第三方库，而是完全使用了 n8n 的 Python (Pyodide) 环境内置的、专门为此设计的工具。它绕开了所有关于操作系统权限和模块缺失的限制。
请将 Code 节点中的代码完整替换为以下内容：
Python
# 这是在 Pyodide 环境中进行网络请求的正确方法 import json # 1. 导入 Pyodide 内置的 http 模块 import pyodide.http # 2. 定义 API 请求所需的所有参数 api_url = 'https://name-crawl4ai.hf.space/crawl_sync' api_token = 'Your token' target_urls = ['https://example.com/'] # 3. 构建请求头 (Headers) 和请求体 (Payload) headers = { 'accept': 'application/json', 'Authorization': f'Bearer {api_token}', 'Content-Type': 'application/json' } payload = { "urls": target_urls } # 4. 使用 pyodide.http.pyfetch 发送请求 # 这是一个异步函数, 所以我们必须在它前面加上 await print("正在使用 Pyodide 内置的 pyfetch 发送 API 请求...") try: response = await pyodide.http.pyfetch( api_url, method='POST', headers=headers, # pyfetch 的 body 参数需要一个字符串, 所以我们用 json.dumps 转换 body=json.dumps(payload) ) # 5. 检查响应是否成功 if not response.ok: # 异步获取错误文本 error_text = await response.string() raise Exception(f"HTTP 错误! 状态码: {response.status}, 详情: {error_text}") print("API 请求成功，已获取数据。") # 6. 异步获取并解析 JSON 数据 data = await response.json() # 7. 按照 n8n 的格式要求返回数据 return [{"json": data}] except Exception as e: print(f"请求失败: {e}") raise e 关键改动解读 import pyodide.http: 我们导入的是 Pyodide 环境特有的模块。
...</p></div><footer class=entry-footer><span title='2025-07-11 00:00:00 +0000 UTC'>七月 11, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;176 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to 正确的Python Code Crawl4ai节点脚本" href=https://hugo.123450908.xyz/posts/2025-07-11/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HF部署的Crawl4AI API 端点用途详解</h2></header><div class=entry-content><p>我们可以把这些端点分为两大类：核心爬取功能和辅助功能。
核心爬取功能 1. POST /crawl_sync (同步爬取 - 您正在使用的) 用途: 这是最直接、最简单的爬取方式。
工作模式 (同步): 您发送一个包含目标网址的请求，然后您的程序会一直等待，直到服务器完成所有的工作（启动浏览器、加载页面、提取内容），最后服务器将完整的结果一次性返回给您。
好比: 去快餐店点餐。您点单、付钱、在柜台前等待，然后直接拿到您的汉堡。一次搞定。
适用场景: 非常适合测试、快速获取单个页面的结果，或者在您自己的脚本不介意等待几秒到几十秒的情况下使用。
2. POST /crawl 和 GET /task/{task_id} (异步爬取 - 两步法) 这两个端点需要组合使用，提供了一种更高级、更强大的工作模式。
用途: 处理可能耗时很长的爬取任务，避免请求超时。
工作模式 (异步):
第一步 (POST /crawl): 您先发送一个爬取请求。服务器收到后，不会马上开始爬取，而是立即返回一个任务ID (task_id)，好比给您一个取餐的号牌。
第二步 (GET /task/{task_id}): 您拿到 task_id 后，可以过一会儿再用这个 ID 去调用 /task/{task_id} 接口，查询任务的进度（例如：排队中、处理中、已完成、失败）。如果任务已完成，这个接口就会返回最终的爬取结果。
好比: 去一家高级餐厅点一道需要精心烹制的菜。您点单后，服务员给您一个订单号，您可以先做点别的事情，隔一段时间再凭订单号询问菜做好了没有。
适用场景: 构建复杂的应用程序，需要同时发起多个爬取任务而不希望程序被卡住；或者当您要爬取的网站非常庞大，预计会花费几分钟甚至更长时间时，使用异步模式可以防止您的请求因为超时而失败。
3. POST /crawl_direct (直接爬取) 用途: 从命名上看，它很可能也是一个同步端点，类似于 /crawl_sync。
推测: “Direct” 可能意味着它绕过了一些高级的内容处理（比如复杂的 Markdown 转换、内容过滤或文章提取），直接返回更“原始”的页面数据（例如，只提取纯文本或基础HTML）。这会让它的处理速度更快，但返回的信息没有经过深度加工。
辅助功能 4. GET /health (健康检查) 用途: 这是一个标准的接口，用于监控服务是否还“活着”。
工作模式: 当您访问这个端点时，如果服务正常，它会返回一个成功的响应（例如 {"status": "ok"}）。自动化监控系统会定期调用这个接口，如果发现调用失败或超时，就会发出警报，提醒管理员服务可能出问题了。
...</p></div><footer class=entry-footer><span title='2025-07-08 00:00:00 +0000 UTC'>七月 8, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;135 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to HF部署的Crawl4AI  API 端点用途详解" href=https://hugo.123450908.xyz/posts/2025-07-08/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://hugo.123450908.xyz/posts/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://hugo.123450908.xyz/>Rain Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>