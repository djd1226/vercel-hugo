<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Rain Blog</title>
<meta name=keywords content><meta name=description content="Posts - Rain Blog"><meta name=author content="Afer_rain"><link rel=canonical href=https://hugo.123450908.xyz/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://hugo.123450908.xyz/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://hugo.123450908.xyz/posts/index.xml><link rel=alternate hreflang=zh href=https://hugo.123450908.xyz/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://hugo.123450908.xyz/posts/"><meta property="og:site_name" content="Rain Blog"><meta property="og:title" content="Posts"><meta property="og:description" content="like computer"><meta property="og:locale" content="zh"><meta property="og:type" content="website"><meta property="og:image" content="https://hugo.123450908.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://hugo.123450908.xyz/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="like computer"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://hugo.123450908.xyz/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://hugo.123450908.xyz/ accesskey=h title="Home (Alt + H)"><img src=https://hugo.123450908.xyz/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://hugo.123450908.xyz/posts/ title=学习><span class=active>学习</span></a></li><li><a href=https://hugo.123450908.xyz/live/ title=生活><span>生活</span></a></li><li><a href=https://hugo.123450908.xyz/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><header class=page-header style="background-image:url(/images/dd02.webp);background-size:cover;background-position:50%;padding:3rem 1rem;color:#fff;text-shadow:0 2px 4px rgba(0,0,0,.3);text-align:center;position:relative"><div style="position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(to right,rgba(0,0,0,.3),rgba(0,0,0,.1));z-index:0"></div><div style="position:relative;z-index:1;max-width:1200px;margin:0 auto"><h1 style=margin:0;font-size:2.8rem;font-weight:700>Posts</h1></div></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>CSS选择器详解</h2></header><div class=entry-content><p>首先，一个核心概念要明确：
CSS选择器是一套独立的“语言”，它本身与Python或JavaScript无关。 无论你在哪里使用它，语法规则都是完全一样的。
在Python的BeautifulSoup里，你把选择器字符串传给 soup.select('...') 函数。
在JavaScript里，你把同样的字符串传给 document.querySelectorAll('...') 函数。
在CSS样式表里，你直接使用它来定义样式。
所以，学会了怎么写选择器，你就等于掌握了一项在所有这些技术中通用的技能。
JavaScript中如何使用CSS选择器 在JS脚本（尤其是在浏览器控制台里调试时），你主要会用到这两个函数：
document.querySelector('你的选择器')
作用：返回匹配到的 第一个 元素。
特点：如果找不到，返回 null。当你确定只有一个目标时，用它很方便。
document.querySelectorAll('你的选择器')
作用：返回匹配到的 所有 元素，以一个列表（NodeList）的形式。
特点：这是我们爬虫和调试时最常用的！它和Python里的 soup.select() 功能几乎完全一样。如果找不到，返回一个空列表。
这是你在将选择器放入Python代码前，进行测试的最佳方式！
CSS选择器参数写法“速查宝典” 下面，我为你整理了一份从入门到精通的CSS选择器写法“秘笈”，并结合 docs.crawl4ai.com 的例子来说明。
1. 基础选择器 (The Basics) 类型
语法
例子 (针对crawl4ai)
解释
标签
tag
h1
选取所有 &lt;h1> 标签。
类名
.classname
.terminal-mkdocs-side-nav-item
选取所有 class 属性包含这个类名的元素。
ID
#idname
#Introduction
选取 id 属性等于 Introduction 的元素（ID在页面中应唯一）。
2. 组合选择器 (Relationships) 这是最强大的部分，用来描述元素之间的层级关系。
类型
语法
例子
解释
后代
A B
...</p></div><footer class=entry-footer><span title='2025-07-14 00:00:00 +0000 UTC'>七月 14, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;258 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to CSS选择器详解" href=https://hugo.123450908.xyz/posts/2025-07-14/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>n8n使用code节点清洗数据</h2></header><div class=entry-content><p>crawl4ai真实数据结构，raw_markdown 的正确路径是：
item.json.results[0].markdown_v2.raw_markdown
我们来分解一下这个正确的路径：
item：这是 n8n 传给 Code 节点的单个数据项，它的顶层就有一个叫 "json" 的对象。
.json：进入这个 "json" 对象。
.results：在 "json" 对象内部，找到 "results" 字段，它是一个数组 [ ... ]。
[0]：从这个数组中，取出第一个元素（因为编号从0开始）。
.markdown_v2：在这个元素对象中，找到 "markdown_v2" 字段。
.raw_markdown：最后，从 "markdown_v2" 对象中，取出我们最终需要的 "raw_markdown" 文本。
你之前的尝试都非常接近，只是因为 crawl4ai 的输出实际上被包裹在了另一层 json 对象里，这是我们之前无法预料到的。你通过 console.log 把它找了出来，这正是最专业的调试方法！
最终的 n8n Code 节点代码 现在，请将你的 Code 节点代码完整替换为下面这个最终正确版本。它使用了正确的路径，并且依然保持了“健壮性”，可以防止因为未来可能的抓取失败而导致工作流崩溃。
JavaScript
// 获取上一个节点传入的所有数据项 const items = $input.all(); // 遍历每一个数据项进行处理 for (const item of items) { // 使用我们最终确定的正确路径来安全地访问数据 let text = item.json?.results?.[0]?.markdown_v2?.raw_markdown; if (text) { // --- 最终清理流程 --- // 1. 【关键新增步骤】将字符串 "\\n" 替换为真正的换行符 \n // 这是解决你看到 `\n` 而不换行的核心 text = text.replaceAll('\\n', '\n'); // 2. 定义一个更全面的“垃圾内容”关键词黑名单 const junkKeywords = [ '分类', '图像来源', '图像加注文字', '补充报导：BBC国际部', 'Article Information', 'Author,', 'Role,', '热读', 'End of 热读', '更多相关内容', '热门内容', '特别推荐', 'BBC值得信赖的原因', '© 2025 BBC' ]; // 3. 先用更强的正则表达式，移除所有图片和链接的 Markdown 标记 text = text.replace(/(!?\[[\s\S]*?\]\([\s\S]*?\))+/g, ''); // 4. 【核心改进】按行处理，用更严格的规则过滤 const lines = text.split('\n'); const cleanedLines = lines .map(line => line.trim()) // 去除每行首尾的空格 .filter(line => { // 规则a: 过滤掉空行 if (line.length === 0) return false; // 规则b: 过滤掉无意义的符号行 if (line === '*' || line === '###') return false; // 规则c: 过滤掉类似 "1. 1" 或 "10. 10" 这样的错误行 if (/^\d+\.\s\d+$/.test(line)) return false; // 规则d: 过滤掉看起来像单独日期的行 if (/^\d{4}年\d{1,2}月\d{1,2}日$/.test(line) || /^\d+\s小时前$/.test(line)) return false; // 规则e: 如果行内包含任何一个黑名单关键词，就过滤掉它 if (junkKeywords.some(keyword => line.includes(keyword))) return false; return true; // 保留所有“干净”的行 }); // 5. 将干净的行重新组合，并整理段落格式 let cleanedText = cleanedLines.join('\n'); cleanedText = cleanedText.replace(/\n{3,}/g, '\n\n'); // --- 清理流程结束 --- item.json.cleaned_markdown = cleanedText.trim(); } else { item.json.cleaned_markdown = "处理失败：未能在指定的路径中找到内容。"; } } // 返回被修改后的数据项 return items;</p></div><footer class=entry-footer><span title='2025-07-13 00:00:00 +0000 UTC'>七月 13, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;230 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to n8n使用code节点清洗数据" href=https://hugo.123450908.xyz/posts/2025-07-13/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>正确的Python Code Crawl4ai节点脚本</h2></header><div class=entry-content><p>正确的 Python Code ___Crawl4ai 节点脚本 这次的方案不再依赖任何需要从外部安装的第三方库，而是完全使用了 n8n 的 Python (Pyodide) 环境内置的、专门为此设计的工具。它绕开了所有关于操作系统权限和模块缺失的限制。
请将 Code 节点中的代码完整替换为以下内容：
Python
# 这是在 Pyodide 环境中进行网络请求的正确方法 import json # 1. 导入 Pyodide 内置的 http 模块 import pyodide.http # 2. 定义 API 请求所需的所有参数 api_url = 'https://name-crawl4ai.hf.space/crawl_sync' api_token = 'Your token' target_urls = ['https://example.com/'] # 3. 构建请求头 (Headers) 和请求体 (Payload) headers = { 'accept': 'application/json', 'Authorization': f'Bearer {api_token}', 'Content-Type': 'application/json' } payload = { "urls": target_urls } # 4. 使用 pyodide.http.pyfetch 发送请求 # 这是一个异步函数, 所以我们必须在它前面加上 await print("正在使用 Pyodide 内置的 pyfetch 发送 API 请求...") try: response = await pyodide.http.pyfetch( api_url, method='POST', headers=headers, # pyfetch 的 body 参数需要一个字符串, 所以我们用 json.dumps 转换 body=json.dumps(payload) ) # 5. 检查响应是否成功 if not response.ok: # 异步获取错误文本 error_text = await response.string() raise Exception(f"HTTP 错误! 状态码: {response.status}, 详情: {error_text}") print("API 请求成功，已获取数据。") # 6. 异步获取并解析 JSON 数据 data = await response.json() # 7. 按照 n8n 的格式要求返回数据 return [{"json": data}] except Exception as e: print(f"请求失败: {e}") raise e 关键改动解读 import pyodide.http: 我们导入的是 Pyodide 环境特有的模块。
...</p></div><footer class=entry-footer><span title='2025-07-11 00:00:00 +0000 UTC'>七月 11, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;176 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to 正确的Python Code Crawl4ai节点脚本" href=https://hugo.123450908.xyz/posts/2025-07-11/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>HF部署的Crawl4AI API 端点用途详解</h2></header><div class=entry-content><p>我们可以把这些端点分为两大类：核心爬取功能和辅助功能。
核心爬取功能 1. POST /crawl_sync (同步爬取 - 您正在使用的) 用途: 这是最直接、最简单的爬取方式。
工作模式 (同步): 您发送一个包含目标网址的请求，然后您的程序会一直等待，直到服务器完成所有的工作（启动浏览器、加载页面、提取内容），最后服务器将完整的结果一次性返回给您。
好比: 去快餐店点餐。您点单、付钱、在柜台前等待，然后直接拿到您的汉堡。一次搞定。
适用场景: 非常适合测试、快速获取单个页面的结果，或者在您自己的脚本不介意等待几秒到几十秒的情况下使用。
2. POST /crawl 和 GET /task/{task_id} (异步爬取 - 两步法) 这两个端点需要组合使用，提供了一种更高级、更强大的工作模式。
用途: 处理可能耗时很长的爬取任务，避免请求超时。
工作模式 (异步):
第一步 (POST /crawl): 您先发送一个爬取请求。服务器收到后，不会马上开始爬取，而是立即返回一个任务ID (task_id)，好比给您一个取餐的号牌。
第二步 (GET /task/{task_id}): 您拿到 task_id 后，可以过一会儿再用这个 ID 去调用 /task/{task_id} 接口，查询任务的进度（例如：排队中、处理中、已完成、失败）。如果任务已完成，这个接口就会返回最终的爬取结果。
好比: 去一家高级餐厅点一道需要精心烹制的菜。您点单后，服务员给您一个订单号，您可以先做点别的事情，隔一段时间再凭订单号询问菜做好了没有。
适用场景: 构建复杂的应用程序，需要同时发起多个爬取任务而不希望程序被卡住；或者当您要爬取的网站非常庞大，预计会花费几分钟甚至更长时间时，使用异步模式可以防止您的请求因为超时而失败。
3. POST /crawl_direct (直接爬取) 用途: 从命名上看，它很可能也是一个同步端点，类似于 /crawl_sync。
推测: “Direct” 可能意味着它绕过了一些高级的内容处理（比如复杂的 Markdown 转换、内容过滤或文章提取），直接返回更“原始”的页面数据（例如，只提取纯文本或基础HTML）。这会让它的处理速度更快，但返回的信息没有经过深度加工。
辅助功能 4. GET /health (健康检查) 用途: 这是一个标准的接口，用于监控服务是否还“活着”。
工作模式: 当您访问这个端点时，如果服务正常，它会返回一个成功的响应（例如 {"status": "ok"}）。自动化监控系统会定期调用这个接口，如果发现调用失败或超时，就会发出警报，提醒管理员服务可能出问题了。
...</p></div><footer class=entry-footer><span title='2025-07-08 00:00:00 +0000 UTC'>七月 8, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;135 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to HF部署的Crawl4AI  API 端点用途详解" href=https://hugo.123450908.xyz/posts/2025-07-08/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>API 请求映射到 n8n</h2></header><div class=entry-content><p>如何将任何代码（无论是 curl、Python 还是 JavaScript）中的 API 请求，映射到 n8n 的 HTTP Request 节点上。
第一步：理解一个 API 请求的“四要素” 无论用什么工具，一个标准的 HTTP API 请求（特别是 POST 请求）通常都由四个核心部分组成，就像寄一个快递一样：
方法 (Method): 你想让服务器做什么操作。(POST, GET, PUT, DELETE 等)
好比: 告诉快递员你是要“寄件”(POST) 还是“查件”(GET)。 网址 (URL): 你要把请求发送到哪里。
好比: 快递包裹上的“收件人地址”。 请求头 (Headers): 关于这次请求的“元数据”或“说明书”。
好比: 快递单上的附加信息，比如“内含易碎品”(Content-Type)、“寄件人身份证号”(Authorization)。它描述的是这个包裹本身，而不是里面的东西。 请求体 (Body): 你实际发送给服务器的数据。
好比: 你要寄送的“包裹里的物品”。 n8n 的 HTTP Request 节点界面，就是围绕这“四要素”设计的，只不过是用图形化的方式来呈现。
第二步：将脚本代码与“四要素”对应 让我们以我们最终成功的 curl 命令为例，因为它最能清晰地体现这四要素：
Bash
curl -X POST \ 'https://rain1226-crawl4ai.hf.space/crawl_sync' \ -H 'Content-Type: application/json' \ -H 'Authorization: Bearer password' \ -d '{ "urls": ["https://www.python.org"], "crawler_options": {} }' 我们来分解这个命令：
...</p></div><footer class=entry-footer><span title='2025-07-07 00:00:00 +0000 UTC'>七月 7, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;256 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to API 请求映射到 n8n" href=https://hugo.123450908.xyz/posts/2025-07-07/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>从搜狗双拼切换到小鹤双拼面</h2></header><div class=entry-content><p>零声母音节的处理方式（这是最根本的区别）。 部分韵母的键位定义。 下面我将为您详细拆解，并提供记忆方法，助您平稳过渡。
一、最大的不同：零声母的处理方式 这是您需要建立的第一个新习惯，也是小鹤方案高效的原因之一。
搜狗双拼 (旧习惯)：
处理零声母音节（如 a, an, ang, o, ou 等）时，需要先按下一个虚拟的“零声母引导键”，通常是 O 键。
输入“安”(an)：需要按 O + J (J是搜狗方案里an的键位)。 输入“昂”(ang)：需要按 O + D (D是搜狗方案里ang的键位)。 小鹤双拼 (新习惯)：
彻底抛弃了零声母引导键。直接将零声母音节的第一个字母视为声母。
输入“安”(an)：直接按 an 所在的键，即 J 键（a在A，n在N，所以an双拼在J）。 输入“昂”(ang)：直接按 ang 所在的键，即 K 键。 输入“爱”(ai)：直接按 ai 所在的键，即 D 键。 您需要做的改变： 忘记 O 键！以后凡是遇到 a, e, o 开头的音节，就把它当成一个普通的双拼音节直接输入即可。这是最核心、最重要的一个转变。
二、需要重新记忆的韵母键位 许多键位在两个方案中是相同的，这会减轻您的学习负担。我们重点关注那些发生了变化的键位。
下表清晰地列出了所有不同点，以及帮助您记忆的“小鹤口诀”提示。
韵母
搜狗双拼键位 (旧)
小鹤双拼键位 (新)
记忆提示与口诀（重点看）
韵母 搜狗双拼键位 (旧) 小鹤双拼键位 (新) 记忆提示与口诀（重点看） ai L D 爱(ai)戴(dài) -> ai 在 D an M J 安(an)静(jìng) -> an 在 J ang D K 昂(áng)首挺胸看(k) -> ang 在 K ianguang K L 姑娘(niáng)靓(liàng) -> iang 在 L ong S H 轰(hōng)隆隆 -> ong 在 H iong S Y 穷(qióng)困潦倒用(y)钱 -> iong 在 Y ing H Y 英(yīng)雄 -> ing 和 iong 都在 Y in J N 因(yīn)为(n) -> in 在 N (本身就是N) un Y P 温(wēn)柔一刀劈(pī) -> un 在 P 快速总结您需要重点练习的8个新键位：D, J, K, L, H, Y, N, P。
...</p></div><footer class=entry-footer><span title='2025-06-21 00:00:00 +0000 UTC'>六月 21, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;185 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to 从搜狗双拼切换到小鹤双拼面" href=https://hugo.123450908.xyz/posts/2025-06-21/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>自选Reality的目标网站</h2></header><div class=entry-content><p>选择目标网站需满足的条件目标网站要满足4个条件： 最主要的是TLs1.3、H2协议和是否套了CDN
1.1、使用Tls1.3协议 ：tls是传输层安全协议，1.3是Tls1.2的升级版，访问速度更快刚安全 1.2、X25519：是一种签名算法，TLS 1.3 标准支持使用 X25519，速度快，数据量小，用来申请证书 1.3、H2协议：即HTTP2.0，简称h2，引入了Stream，实现对一个 TCP 连接的多路复用，极大提高了传输性能 1.4、未套CDN：对于非reality节点的数据转发到dest时，如果reality的dest目标网站套了CDN，这些数据会被自动转发到CF的CDN节点，CDN节点我们的reality节点就变成了别人的反代加速节点。因此目标网站不能使用套CDN的域名，如怎么判断是否套了CDN? 查看是否套用了CDN： 在目标网站域名后添加 /cdn-cgi/trace 是Cloudflare的CDN 调试接口，所有托管在 Cloudflare 上的网站都存在这个接口，并且套了CDN的网站都会使用Cloudflare签发的证书! Reality目标网站获取方式目标网站获取有三种方式 是选取第三方平台测试完的网站 是自己动手搜索合适的网站 是通过工具本地搜索获取 第一种方式简单，网站已经为我们筛选好了，只要符合目标网站的几个特征可拿来直接使用，但无法指定区域与自己的VPS离得可能很远，对访问速度会有影响。第二种方式可以自定义查找离自己服务器近的可用网站，操作相对灵活，但操作上稍微繁琐需要一定的动手能力。第三种方式可以方便获得目标网站，但与第一种一样无法指定区域。 第一种方式：网站直接获取https://www.ssllabs.com/ssltest/index.htmlhttps://securityheaders.com/ 第二种方式：FOFA手动搜索获取ASN查询工具：https://tools.ipip.net/as.php目标网站查询工具：https://fofa.info 查询命令： > asn=="16509" && country=="US" && port=="443" && cert!="Let's Encrypt" && cert.issuer!="ZeroSSL" && status_code="200" 这句话的意思是查询自己vps自治域美国区域，端口为443，不是由临时证书颁发机构颁发的证书，且http请求成功的网站。Let’s Encrypt与ZeroSSL都是免费证书，有效期都是90天 asn：（自治域号码） port==“443” （端口） cert!=“Let’s Encrypt” （不是Let’s Encrypt类型的证书） cert.issuer!=“ZeroSSL”（证书颁发者不是ZeroSSL） status_code=“200”（HTTP 响应状态码，200的意思是Http请求成功） 4. 本地工具获取目标网站RealiTLScanner：https://github.com/XTLS/RealiTLScanner/releases3.1 在软件目录打开命令行窗口 CMD3.2 运行命令：将命令行中的1.1.1.1IP地址更换为自己VPS的IP地址
.\RealiTLScanner-windows-64.exe -addr 1.1.1.1 -port 443 -thread 100 -timeOut 5</p></div><footer class=entry-footer><span title='2025-05-28 00:00:00 +0000 UTC'>五月 28, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;66 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to 自选Reality的目标网站" href=https://hugo.123450908.xyz/posts/2025-05-28/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>使用 `sabre/dav` 库----WebDAV 教程</h2></header><div class=entry-content><p>安装sabre/dav 库 WebDAV 入门教程 (基于 sabre/dav)
第一部分：什么是 WebDAV？
WebDAV (Web Distributed Authoring and Versioning) 是一种基于 HTTP 协议的扩展，允许客户端像操作本地文件一样，对服务器上的文件进行创建、读取、修改和删除等操作。 简单来说，它让你可以通过网络像访问本地硬盘一样访问服务器上的文件。
第二部分：准备工作
在开始之前，请确保您已经安装了以下软件：
PHP: 确保您的 PHP 版本符合 sabre/dav 的要求 (通常是 PHP 7.4 或更高版本)。 Composer: Composer 是 PHP 的依赖管理工具。如果您还没有安装，请访问 https://getcomposer.org/ 下载并安装。 Web 服务器 (例如 Apache 或 Nginx): 用于运行您的 PHP 代码。 第三部分：安装 sabre/dav
创建项目目录： 首先，创建一个新的目录来存放您的 WebDAV 项目。
mkdir my-webdav-server cd my-webdav-server 使用 Composer 安装 sabre/dav： 在项目目录中，运行以下命令来安装 sabre/dav 库：
composer require sabre/dav ~4.7.0 这将自动下载并安装 sabre/dav 及其依赖项。
...</p></div><footer class=entry-footer><span title='2025-05-25 00:00:00 +0000 UTC'>五月 25, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;483 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to 使用 `sabre/dav` 库----WebDAV 教程" href=https://hugo.123450908.xyz/posts/2025-05-25/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Cloudflare+resend无限多企业邮箱，可收发邮件</h2></header><div class=entry-content><p>在赛博大善人cloudflare那里白嫖无限多个企业级邮箱，这些邮箱既可以收邮件，也可以发邮件。 可以用来接收网站验证码，注册账户的时候就可以很方便的注册一大堆小号。 还可以把他们当成临时邮箱，与人通信，避免暴露自己真实的邮箱，保护个人隐私。 Cloudflare是一家提供CDN、网络安全、DDos防御和域名服务的公司。人称大善人，赛博活佛，让你瞬间获得无限多个免费邮箱!
我已经配置好了所有发送到me.xyz域名下面的邮件都会自动转到我的163的邮箱 。这样就实现了无限多个邮箱可以收邮件！
发邮件 使用邮箱发送邮件，我使用的服务是**resend.com** ，这也是一个免费的服务。没有账号的话就自己注册一个(github账户登录），然后添加一个自己的API Keys！ 我已经配置好可以通过任何一个我的xyz域名邮箱来发送邮件，如name@123.xyz
使用Python发邮件 # 先安装依赖 # pip install resend import resend # 这里换成自己的resend API Key resend.api_key = "re_xxxxxxxxxxxxxxxxxxxxxxx" params: resend.Emails.SendParams = { # 发件人可以是自己域名下的任何一个人 "from": "name@123.xyz", "to": ["name@qq.com"], "subject": "hi", "html": "&lt;strong>hello, world!&lt;/strong>" } email = resend.Emails.send(params) print(email) 使用cURL发邮件 Authorization 换成自己的resend API Key
发件人可以是自己域名下的任何一个人
curl -X POST 'https://api.resend.com/emails' \ -H 'Authorization: Bearer re_VxeNCEn1_6w4bYF93xQKgKGFYRxNK2D3J' \ -H 'Content-Type: application/json' \ -d ```{ "from": "Acme &lt;name@你的域名>", "to": ["name@qq.com"], "subject": "hello world", "text": "it works!" }' 使用Smtp发件 使用Smtp发件，服务器地址为smtp.resend.com，端口为25/465/587/2465/2587，用户名为resend，密码为 apikey。详见 文档</p></div><footer class=entry-footer><span title='2025-05-20 00:00:00 +0000 UTC'>五月 20, 2025</span>&nbsp;·&nbsp;1 分钟&nbsp;·&nbsp;85 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to Cloudflare+resend无限多企业邮箱，可收发邮件" href=https://hugo.123450908.xyz/posts/2025-05-20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Nginx 配置反向代理指向本机的不同服务</h2></header><div class=entry-content><p>通用的 Nginx 配置，通过 反向代理 将不同的域名指向本机的不同服务。所有的虚拟主机都会监听 80 端口，但通过不同的 server_name 来访问不同的服务。
配置示例 假设你有多个服务运行在本机的不同端口上（例如 8080, 8081, 8082 等），并且你希望通过不同的域名来访问这些服务。
配置结构： service1.com 访问本机的服务（比如：端口 8080）。 service2.com 访问本机的服务（比如：端口 8081）。 service3.com 访问本机的服务（比如：端口 8082）。 Nginx 配置文件 server { listen 80; server_name service1.com www.service1.com; location / { proxy_pass http://127.0.0.1:8080; # 转发到本机的 8080 端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } server { listen 80; server_name service2.com www.service2.com; location / { proxy_pass http://127.0.0.1:8081; # 转发到本机的 8081 端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } server { listen 80; server_name service3.com www.service3.com; location / { proxy_pass http://127.0.0.1:8082; # 转发到本机的 8082 端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 配置说明： server_name：每个 server 块都有不同的 server_name，这会让 Nginx 根据请求的域名来决定应该使用哪个配置块来处理请求。 proxy_pass：将请求反向代理到本机的不同端口（如 8080、8081、8082 等）。这里假设你有三个服务分别运行在这些端口。 proxy_set_header：这些指令确保 Nginx 正确地传递一些头信息，保留客户端的原始请求信息，包括： X-Real-IP：客户端的真实 IP 地址。 X-Forwarded-For：通过代理传递的 IP 地址链。 X-Forwarded-Proto：用于知道请求使用的协议（HTTP 或 HTTPS）。 Host：客户端请求的域名。 访问方式 当用户访问 http://service1.com 时，Nginx 会将请求反向代理到本机的 http://127.0.0.1:8080。 当用户访问 http://service2.com 时，Nginx 会将请求反向代理到本机的 http://127.0.0.1:8081。 当用户访问 http://service3.com 时，Nginx 会将请求反向代理到本机的 http://127.0.0.1:8082。 注意事项 DNS 配置：确保你在 DNS 上正确配置了 service1.com, service2.com, service3.com 等域名，使其指向你的服务器 IP。 服务端口：确保目标服务（例如，8080、8081、8082 等）已经在本地正确启动，并且能响应请求。 防火墙设置：确保防火墙允许 Nginx 访问这些服务端口。 小结 通过这种方式，你可以利用不同的域名来访问本机的不同服务，且不需要为每个服务单独配置不同的端口，所有的请求都通过 80 端口进行访问，非常适合做反向代理。
...</p></div><footer class=entry-footer><span title='2025-05-18 00:00:00 +0000 UTC'>五月 18, 2025</span>&nbsp;·&nbsp;2 分钟&nbsp;·&nbsp;389 字&nbsp;·&nbsp;Afer_rain</footer><a class=entry-link aria-label="post link to Nginx 配置反向代理指向本机的不同服务" href=https://hugo.123450908.xyz/posts/2025-05-18/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://hugo.123450908.xyz/posts/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://hugo.123450908.xyz/>Rain Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>